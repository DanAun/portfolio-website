<!DOCTYPE html>
<html lang="en">
<head>
    <title>Building a C-like Compiler and VHDL Microprocessor</title>
    <link rel="icon" type="image/ico" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/projects.css">

    <!-- SEO Metadata -->
    <meta name="description" content="A journey through building a C-like compiler with Flex and Bison, and designing a RISC VHDL microprocessor with a 5-stage pipeline.">
    <meta name="keywords" content="Compiler, VHDL, Microprocessor, RISC, Pipeline, Flex, Bison, Computer Engineering, Daniel Aunan">
    <meta name="author" content="Daniel Aunan">

    <!-- Open Graph -->
    <meta property="og:title" content="Building a C-like Compiler and VHDL Microprocessor">
    <meta property="og:description" content="Developing a simplified C-like compiler and a VHDL microprocessor with RISC pipeline architecture.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://daniel.aunan.org/projects/compiler-vhdl-microprocessor.html">

</head>
<body>
    <header>
        <div class="hotbar">
            <a href="/#projects" class="logo">Port<span>folio</span></a>
        </div>
    </header>

    <main class="project-page">
        <h1 class="project-title">Building a C-like Compiler and VHDL Microprocessor</h1>
        <p class="intro">
            This project was a true crash course in bridging the gap between theory and practice.
            As part of my studies at INSA Toulouse, I set out to design both a compiler for a simplified C-like language
            and a custom VHDL microprocessor capable of executing the generated machine code.
            It was the first time I had to take an abstract idea—"make a language run on a processor"—and actually implement the entire chain.
        </p>

        <section>
            <h2>The Challenge</h2>
            <p>
                At first, the task looked overwhelming: three moving parts that all had to work together.
                On one side, the <strong>compiler</strong> had to translate human-readable code into structured instructions.
                On the other, a <strong>microprocessor</strong> needed to understand and execute those instructions.
                And between them was the delicate interface: assembly code that had to be syntactically precise and semantically sound.
            </p>
        </section>

        <section>
            <h2>Compiler: From Text to Instructions</h2>
            <p>
                I began with the compiler, which we split into two classic stages: lexical analysis and syntax analysis.
            </p>

            <h3>Lexical Analysis with Flex</h3>
            <p>
                Using <code>Flex</code>, I built a lexical analyzer that could recognize tokens such as keywords (<code>if</code>, <code>while</code>), 
                identifiers, numbers (including hexadecimal and scientific notation), and operators (<code>+</code>, <code>-</code>, <code>*</code>).
                It also handled comments gracefully and threw errors for unknown tokens.
                Running the lexer felt like watching raw code come alive, structured into pieces ready for deeper analysis.
            </p>

            <h3>Syntax Analysis with Bison</h3>
            <p>
                The syntax analyzer, written with <code>Bison</code>, checked these tokens against grammar rules.  
                It supported function declarations, arithmetic expressions, conditionals, and loops.
                To keep everything consistent, I used a symbol table to track variables and functions,
                while an assembly table produced machine-ready instructions.
                This was where the compiler truly "spoke" to the hardware level.
            </p>
        </section>

        <section>
            <h2>Microprocessor: Bringing Code to Life</h2>
            <p>
                With the compiler generating assembly, the next step was to build a processor that could run it.
                Designed in VHDL, my microprocessor followed a <strong>RISC 5-stage pipeline</strong> architecture.
                It included:
            </p>
            <ul>
                <li>Instruction set: <code>ADD</code>, <code>MUL</code>, <code>SOU</code>, <code>COP</code>, <code>AFC</code>, <code>LOAD</code>, <code>STORE</code></li>
                <li>A register bank and memory management system</li>
                <li>An ALU capable of arithmetic and logical operations</li>
                <li>Hazard detection in the second pipeline stage to handle conflicts</li>
            </ul>
            <p>
                For me, the breakthrough moment was watching my own assembly instructions
                actually run in a Vivado simulation—proof that the compiler and microprocessor were finally in sync.
            </p>
        </section>

        <section>
            <h2>Lessons Learned</h2>
            <p>
                This project taught me that building a system end-to-end is more than just coding each part correctly.  
                It's about designing clear interfaces between layers, and anticipating how design choices in one layer
                ripple down into the others. Debugging across both the compiler and the processor forced me to think systematically,
                which is a skill I now carry into my work in cybersecurity.
            </p>
        </section>

        <div class="project-actions">
            <a href="https://github.com/DanAun/compiler-and-vhdl-microprocessor" class="button">View on GitHub</a>
        </div>

        <section>
            <h2>Figures</h2>
            <div class="figures-container">
                <figure>
                    <img src="/images/project1/project1-fig1.png" alt="Table showing the implemented instructions">
                    <figcaption>Figure 1: Instruction set implemented for the microprocessor.</figcaption>
                </figure>
                <figure>
                    <img src="/images/project1/project1-fig2.png" alt="Pipeline architecture diagram">
                    <figcaption>Figure 2: RISC 5-stage pipeline architecture in VHDL.</figcaption>
                </figure>
                <figure>
                    <img src="/images/project1/project1-fig3.png" alt="Vivado simulation of the microprocessor">
                    <figcaption>Figure 3: Simulation of machine code execution in Vivado.</figcaption>
                </figure>
            </div>
        </section>
    </main>
</body>
</html>
